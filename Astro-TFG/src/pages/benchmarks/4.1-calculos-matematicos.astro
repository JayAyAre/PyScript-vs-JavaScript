---
import '../../styles/global.css';
import Layout from '../../layouts/BenchmarkLayout.astro';

const benchmark = {
    title: '1. Cálculos matemáticos intensivos',
    link: '/4.1-calculos-matematicos',
    description:
        'Estas pruebas medirán la eficiencia de cada tecnología al ejecutar operaciones matemáticas de alto costo computacional, como transformaciones numéricas, factorizaciones, cálculos algebraicos, entre otros. Con el objetivo principal de evaluar el rendimiento en operaciones típicas que se usarían en el ámbito científico del desarrollo web.',
    warning:
        'En estos escenarios también se decidió evaluar el rendimiento de las pruebas teniendo en cuenta que se ejecutan en el hilo principal. Es decir, no habrá un worker que ejecute las pruebas para que se pueda interactuar con la página web. Por ello, al ejecutar las pruebas, se congelará el hilo principal hasta que finalice la prueba. Por otro lado, al ser PyScript, habrá un tiempo de carga de la página web que no se puede evitar, por lo que es posible que la prueba tarde un poco antes de estar disponible.',
    tests: [
        {
            title: 'Multiplicación de matrices',
            description:
                'El propósito de esta prueba es principalmente evaluar y comparar el rendimiento del manejo de matrices, tanto en su manipulación como en su operación, de tal manera que se observe cuán eficiente es el uso de las estructuras nativas de ambas herramientas y de aquellas incluidas en librerías externas.',
            versions: [
                {
                    title: 'Estructuras de Datos Nativas',
                    description:
                        'Esta versión usará estructuras de datos nativas sin usar librerías externas. Consistirá en realizar la operación de multiplicación de matrices mediante bucles anidados. La matriz a operar será de 300×300 y con valores entre 0 y 1.',
                },
                {
                    title: 'Estructuras de Datos Optimizadas',
                    description:
                        'Esta versión usará estructuras de datos optimizadas que pueden ser de librerías externas, tanto en Python con NumPy como en JS usando TypedArrays. Consistirá en realizar la operación de multiplicación de matrices mediante funciones de librerías. La matriz puede ser de 500×500, 1000×1000 o 2000×2000 y con valores entre 0 y 1.',
                },
            ],
        },
        {
            title: 'Evaluación del rendimiento en la detección de números primos',
            description:
                'El propósito de esta prueba es evaluar y comparar el rendimiento de algoritmos convencionales y optimizados en JavaScript y Python para la detección de números primos. Con esta prueba podremos observar cuán eficiente es el uso de diferentes algoritmos matemáticos y cuál es la diferencia entre ambos.',
            versions: [
                {
                    title: 'Algoritmos Convencionales (Estructuras Nativas)',
                    description:
                        'Esta versión usará estructuras de datos nativas y comprobará divisibilidad básica hasta la raíz cuadrada del número. El rango máximo será hasta 10⁶.',
                },
                {
                    title: 'Algoritmos Optimizados con Librerías Especializadas',
                    description:
                        'Esta versión empleará librerías optimizadas para la detección de números, usando el algoritmo de la criba de Eratóstenes. El rango máximo será hasta 10⁴ y se ejecutará 1000 veces para obtener una medición estadística.',
                },
            ],
        },
        {
            title: 'Cálculo de dígitos de π',
            description:
                'El objetivo de esta prueba es evaluar el rendimiento de Python y JavaScript en el cálculo de dígitos de π, tanto sin usar como usando precisión arbitraria. Se busca medir cómo afecta el uso de estructuras de datos nativas y optimizadas a la velocidad de cálculo y al consumo de memoria. Al indicar “precisión arbitraria” se quiere señalar que el algoritmo calcula dígitos que no se pueden representar exactamente con un número de bits, como un float o double.',
            versions: [
                {
                    title: 'BBP (Estructuras nativas) sin precisión arbitraria',
                    description:
                        'Se calcularán N=10³ dígitos de π con la implementación de la fórmula BBP usando estructuras nativas. Esta simulación se ejecutará 1000 veces para obtener una medición estadística.',
                },
                {
                    title: 'Gauss–Legendre (Estructuras optimizadas) con precisión arbitraria',
                    description:
                        'Se calcularán N=10⁴ dígitos de π con la implementación de Gauss–Legendre usando estructuras optimizadas. Esta simulación se ejecutará 10 veces para obtener una medición estadística mínima.',
                },
            ],
        },
    ],
};
---

<Layout {...benchmark} />
